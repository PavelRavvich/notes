Примитивные типы Java
____________________________
byte - 1 байт (8 бит). Мин -2^7 макс 2^7-1
short - 2 байта (16 бит). Мин -2^15 Макс 2^15-1
char - 2 байта (16 бит). 2^16-1
int - 4 байта (32 бит). Мин -2^31-1 Макс 2^31
long - 8 байт (64 бит). Мин -2^63-1 Макс 2^63
float - 4 байта (32 бит). Мин -2^31-1 Макс 2^31
double - 8 байт (64 бит). Мин -2^63-1 Макс 2^63
boolean - по спецификации не определен в среднем 1 байт

XML
________
1. DOM - обход XML документа в оба направления, грузит весь документ в память подходит для небольших файлов
2. Stax - Событийный, грузит документ частями, подходит для мелких документов. Работает по пул модели. Позволяет обрабатывать только те события которые нам необходимы. Позволяет писать в XML файл.
3. Sax - Событийный, грузит документ частями, позволяет работать с большими документам, работает по пуш модели необходимо обрабатывать все события.


SOLID
_______
1. S - Принцип единственной ответственности. Каждый класс должен отвечать за одну определенную роль в программе.
2. O - Принцип открытости закрытости. Класс должен быть открыт для расширения и закрыт для изменения.
3. L - Принцип подстановки Барбары Лисков. Объекты должны быть заменяемые на экземпляры их подтипов.
4. I - Принцип разделения интерфейса. Много интерфейсов специального назначения лучше, чем один интерфейс общего назначения.
5. D - Принцип подстановки зависимостей. Зависимость на абстракцию. Нету зависимости на конкретную реализацию.

EQUALS/HASHCODE
____________________
Метод equals() обозначает отношение эквивалентности объектов. Эквивалентным называется отношение, которое является симметричным, транзитивным, рефлексивным и постоянным.
1. Рефлексивность: для любого ненулевого x, x.equals(x) вернет true;
2. Транзитивность: для любого ненулевого x, y и z, если x.equals(y) и y.eqals(z) вернет true, тогда и x.equals(z) вернет true;
3. Постоянство: для любых объектов x и y x.equals(y) возвращает одно и тоже, если информация, используемая в сравнениях, не меняется;
4. Симметричность: для любого ненулевого x и y, x.equals(y) должно вернуть true, тогда и только тогда, когда y.equals(x) вернет true.

Метод хешкод
Если хешкод двух объектов равен - это не значит что 2 объекта равны по equals
Если хешкод двух объектов не равен - значит объекты не равны по equals


Serializable/Externalizable
_____________________________
Интерфейс маркер Serializable. Для записи обьекта используется ObjectOutputStream с private методом writeObject() для чтения ObjectInputStream с методом private readObject()
Thread, OutputStream и его подклассы, и Socket - не сериализуемые
Transient - помечает объект который сериализовать не нужно.
Если мы не хотим сериализовать наследника чей супер класс помечен Serializable то в этом наследнике переопределив методы writeObject() и readObject() кидаем throw new NotSerializableException();

Интерфейс Externalizable содержит 2 метода 
public void writeExternal(ObjectOutput out) throws IOException;
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;
serialVersionUID - версионность сериализованного объекта (например избавляет от проблемы когда добавил новое поле, пытаемся десериализовать данный объект из сохраненного ранее состояния и получаем InvalidClassException)
http://www.skipy.ru/technics/serialization.html - почитать

Транзакции
___________________
ACID принципы
1. Атомарность - Все операции либо будут выполнены вместе либо не выполнены вообще.
2. Консистентность - После коммита в БД сохраняются все изменения.
3. Изолированность - Изоляция от внешних воздействий / паралельных транзакций.
4. Надежность - Даже после выключения света все данные останутся в БД

Феномены чтения
Unrepeatable read(Неповторяемость чтения) - Ситуация когда транзакция которая уже получила данные видит уже измененные данные другой транзакции при повторном запросе
Фантомное чтение - Ситуация, когда при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк.
Грязное чтение - Чтение/Добавление/Изменение данных транзакции которая откатиться

Уровни изоляций
Read-uncommited - Чтение незафиксированных данных
Read-commited - Чтение зафиксированных данных
Repetable-read - Повторяемость чтения
Serializable - Упорядочиваемость. Самый медленный спасает от всех проблем
https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D1%8F_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0) - читать


Servlet API - спецификация java расширяющая возможности сервлет контейнера позволяющая обрабатывать HTTP запросы клиента
_______________
жизненный цикл сервлета состоит из следующих шагов:

В случае отсутствия сервлета в контейнере.
Класс сервлета загружается контейнером.
Контейнер создает экземпляр класса сервлета.
Контейнер вызывает метод init(). 
Этот метод инициализирует сервлет и вызывается в первую очередь, до того, как сервлет сможет обслуживать запросы. 
За весь жизненный цикл метод init() вызывается только один раз.
Обслуживание клиентского запроса. Каждый запрос обрабатывается в своем отдельном потоке. 
Контейнер вызывает метод service() для каждого запроса. 
Этот метод определяет тип пришедшего запроса и распределяет его в соответствующий этому типу метод для обработки запроса. 
Разработчик сервлета должен предоставить реализацию для этих методов. 
Если поступил запрос, метод для которого не реализован, вызывается метод родительского класса и обычно завершается возвращением ошибки инициатору запроса.
В случае если контейнеру необходимо удалить сервлет, он вызывает метод destroy(), который снимает сервлет из эксплуатации. Подобно методу init(), этот метод тоже вызывается единожды за весь цикл сервлета.

loadOnStartUp в web.xml
также Сервлет АПИ поддерживает фильтры(метод doFilter) и слушатели событий


Java Server Pages - спецификация
______________________
Технология позволяющая веб-разработчикам создавать содержимое, которое имеет как статические так и динамические компоненты
Код JSP в рантайме компилируется в обычный Servlet а потом джава машина его компилирует в байт код
Внутри JSP можно использовать EL/Скриплеты/taglibs для написание кода 


Spring Framework
__________________________
CORE
Фреймворк для упрощения разработки энтерпрайз приложений. Построен на принцип IOC (Инверсии управления) Использует для этого контейнер джава бинов. Джава бин класс жизненным циклом которого управляет спринг. 
Также спринг использует подход DI Внедрение зависимости используются аннотации @Authowired внедрять можно на поля сеттеры конструкторы / аннотации наследники @Component (@Service / @Repository / @Controller)
Также используются и другие аннотации например @Qualifier для уточнения реализации которую необходимо внедрить
У спринг бинов существуют следующие скоупы:
1. Singleton - Возвращает один и тот же экземляр бина на каждый запрос контейнера Spring IoC (по умолчанию).
2. Prototype - Создает и возвращает новый экземляр бина на каждый запрос.
3. Request - Создает и возвращает экземляр бина на каждый HTTP запрос*.
4. Session - Создает и возвращает экземляр бина для каждой HTTP сессии*.
5. Global-session - Создает и возвращает экземляр бина для глобальной HTTP сессии*.
гуглим документацию и погружаемся


Spring MVC
_____________
DispatcherServlet - основной контроллер фреймворка отвечающий за мапинг запросов на методы контроллеров
Основные используемые аннотации @RestController / @Controller
@RequestMapping
@RequestBody
@ResponceBody
@PathVariable
@RequestParam
Погуглить что это за аннотации и понимать для чего используются
гуглим документацию и погружаемся


SQL
_______________
Почитать про основные команды, оптимизацию запросов и джойны таблиц
https://ru.wikipedia.org/wiki/Join_(SQL) - читать


JPA
_______________
Основные аннотации @Entity @Column @Table @Embedable @MappedSupperClass @Id @ManyToMany @ManyToOne @OneToMany
EntityManager - интерфейс содержащий основные операции над сущностями (persist / refresh / detach/ remove / merge)

http://www.spring-source.ru/docs_simple.php?type=manual&theme=docs_simple&docs_simple=chap03_p01 - почитать основные понятия
http://www.spring-source.ru/docs_simple.php?type=manual&theme=docs_simple&docs_simple=chap04_p08 - почитать про наследование таблиц
гуглим документацию и погружаемся

Многопоточность
_________________
Понимать многопоточность. Блоки синхронизации, мониторы, проблемы многопоточности(дедлоки, рейс кондишен, свич контекст как их избежать), а также понимать как устроен пакет канкаренси
https://habrahabr.ru/post/164487/ - читать
https://habrahabr.ru/company/luxoft/blog/157273/ - читать


JMM
_______________
Понимать как устроена работа с памятью в Java
https://habrahabr.ru/post/84165/ - читать
https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8_Java - читать


Коллекции
_____________
Знать как устроенны коллекции, их иерархия и скорость работы в зависимости от условий
https://habrahabr.ru/post/237043/ - читаем
http://www.quizful.net/post/Java-Collections - читаем
https://habrahabr.ru/post/162017/ - читаем


Дополнительно:

1)Способы аутентификации пользователя
https://habrahabr.ru/company/dataart/blog/262817/
 
2)Паттерны
https://ru.wikipedia.org/wiki/Design_Patterns
 
3)Многопоточность в java
https://habrahabr.ru/post/108016/
https://habrahabr.ru/post/164487/
 
4)Написать реализацию паттерна Singleton
https://habrahabr.ru/post/129494/


5)
Бинарные деревья
https://habrahabr.ru/post/144850/
https://habrahabr.ru/post/65617/
http://www.quizful.net/post/Java-TreeMap

6)
Вопрос на сообразительность:
http://www.programbeginner.ru/?p=99

7)
Hibernate:
http://javastudy.ru/interview/jee-hibernate-questions-answers/ ()

8)
How to define immutable object:
https://docs.oracle.com/javase/tutorial/essential/concurrency/imstrat.html

9)
Abstract Factory vs factory method
https://dzone.com/articles/factory-method-vs-abstract

SPRING-CORE, AOP and MVC(DispatcherServlet - how to work)
