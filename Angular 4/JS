            Прототипы

Прототипная связь работает только на чтение

1. __proto__ если свойство объекта не найдено то JS  идет по этой ссылке к родительскому объекту и тд пока не дойдет до 
Object.__proto__ и только если и там не найдет возвращает undefined
2. prototype это свойство которое есть только у функций. Это ссылка объект у которого есть свойство конструктор которое указывает 
на саму функцию. И когда мы пользуемся функцией-конструктором чтобы создавать много объектов можно сэкономить память. 
У всех этих объектов ссылка __proto__ ссылается на один и тот же прототип и все эти наследники по прототипной цепочке будут 
ссылаться на родителя.



      THIS

Определятся контекстом выполнения функции и будет указывать туда где функция вызвана. И пока функция не вызвана мы ничего сказать 
про this не можем.

1. В общем случае указывает на глобальный объект
2. Если используется use strict то this будет undefined
3. Если функция является методом объекта и вызывается как метод объекта тогда this указывается на сам этот объект.
4. this у обработчика событий указывает на объект на который это событие навешано.
5. Если мы вызываем функцию при помощи оператора new включается прототипом наследование
6. Если функция будет использоваться вне контекста ее надо байндить.

    СОБЫТИЯ

Назначение
1. Прямо в HTML onClick=“javascript code” (Но так нарушается SRP)
2. document.getElementById('my-button').onclick = () => { alert('hello world!') } (Так можно повесить только один обработчик)
3. document.getElementById('my-button'). addEventListener('название_события’, callbackFunction(event) => {…}, options)
options = {
    capture: true // будет ли событие вызываться на этапе погружения от родительского компонента к дочернему или всплытия.
    once: true // удобный способ отписки если элемент удаляется из DOM после нажатия.
    passive: true //
}

У event есть поля:
target - указывает на DOM элемент на котором произошло событие
currentTarget - указывает на DOM элемент на которое навешано событие
preventDefault() - отменяет стандартное поведение (на пример отменить стандартное поведение ссылки)
stopPropagation() - не дает событию всплывать к родителям
stopImmediatePropagation() - не дает сработать соседним обработчикам


Делегирование событий
Событие можно назначить родителю и отфильтровывать лишние ключи при помощи event.target

    ЗАМЫКАНИЯ

Замыкания, это когда есть функция объявленная внутри другой функции (тоесть замкнута на лексическое окружение родителя),
и локальные переменные внутри верхней функции не сбрасываются 
после завершения работы этой верхней функции, а остаются при повторном вызове. Но функция нижнего уровня должна быть возвращаемой.

Замыканиями они называются потому, что младшая функция их замыкает внутри старшей.
function greeting(name) {
    const = text = “Hello “ + name;
    const greet = function() { console.log(text) }
    return greet;
}

